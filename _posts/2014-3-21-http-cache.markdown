---
layout: post
title:  "Http缓存"
date:   2014-3-21 08:18:01
categories: 缓存
---

### 什么是Web缓存，为什么要使用它？

Web缓存游走于服务器和客户端之间。这个服务器可能是源服务器，数量可能是1个或多个；这个客户端也可能是1个或多个。Web缓存就在服务器-客户端之间搞监控，监控请求，并且把请求输出的内容（例如html页面、 图片和文件）（统称为副本）另存一份；然后，如果下一个请求是相同的URL，则直接请求保存的副本，而不是再次请求源服务器。 
     
####使用缓存的2个主要原因：

>1. 降低延迟：缓存离客户端更近，因此，从缓存请求内容比从源服务器所用时间更少，呈现速度更快，网站就显得更灵敏。
>2. 降低网络传输：副本被重复使用，大大降低了用户的带宽使用，同时保证了带宽请求在一个低水平上，更容易维护了。


### Web缓存的类型

#### 1. 浏览器缓存

在任何现代浏览器上(如IE, FireFox, Chrome)，有关于“缓存”的设置选项。浏览器会在你的硬盘上专门开辟一个空间专门为你存储资源副本。

浏览器缓存的工作规则很简单：检查以确保副本是最新的，通常只要一次会话。浏览器缓存在用户触发“后退”操作或点击一个之前看过的链接的时候很管用。同样，如果你在网站上访问同一张图片，该图片可以从浏览器缓存中调出并几乎立即显现出来。

#### 2. 代理服务器缓存
Web代理服务器使用同样的缓存原理，只是规模更大。代理以同样的方式服务千万用户，大公司和ISP经常在他们的防火墙或者单独的设备上架设代理缓存。

由于代理服务器缓存并非客户端或者源服务器的一部分，而是处于网络中，请求需要以某种方式路由到它们。一种方法是手动设置，告诉浏览器的你常用的代理服务器，另外就是使用拦截。拦截代理把Web请求根据自己的底层网络重定向，因此，客户端无需配置，甚至都不需要知道它们。

代理缓存属于一种共享缓存；往往有大量的用户使用，因此，其在降低延时和网络流量上很有用，毕竟每个副本都被大量重用。

#### 3. 网关缓存
也被称为“反向代理缓存”或“替代缓存”。网关缓存同样是起中介作用的，不是网络管理员部署的，是网站管理员他们自己署，这样更容易扩展与维护。    

可以有多种方法把请求路由到网关缓存，但通常使用某种形式的负载均衡器，使它们中的一个或多个看起来像是源服务器。内容分发网络(CDNs)为网络分配网关缓存，然后把这些缓存卖给需要的网站。Speedera和Akamai就是代表性的网络内容发布商。  

>**负载均衡器**：是一种采用各种分配算法把网络请求分散到一个服务器集群中的可用服务器上去，通过管理进入的Web数据流量和增加有效的网络带宽，从而使网络访问者获得尽可能最佳的联网体验的硬件设备。    
>**内容分发网络**：即CDN, 基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互 联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向 离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。  
>**Speedera**：是一家全球性的内容服务提供商，它与北美、欧洲以及亚太地区的1000多家大型运营商都有联系，并为那些不想在自己服务器上寄存内容的公司提供软件下载、媒体及其它服务管理等业务。05年的时候被下面要介绍的Akamai以$130m的价格给收购了。  
>**Akamai**：美国Akamai是国际上最大的CDN服务商，它巨大的网络分发能力在峰值时可达到15Tbps。 Akamai公司是为数不多的旨在消除Internet瓶颈和提高下载速度的几家新公司之一，是一个致力于网络交通提速的”内容发布”公司，是波士顿高技 术区最卓越的新兴企业之一。Akamai公司向全球企业提供发送互联网内容，汇流媒体和应用程序的服务（目前，该公司为15个国家的企业管理着8000多 台服务器）。1998年，丹尼尔。L和麻省理工学院的一些研究人员一起创立了这家公司，他在麻省理工学院的硕士论文构成了Akamai公司最初的”自由 流”（Freeflow）技术的核心。   

### Web缓存无害吗？为什么要鼓励缓存？
 
Web缓存是互联网中最容易被误解的技术之一。网站管理员特别希望知道网站的一举一动，比方说多少人访问啦，访问时间啊什么的，而缓存会“隐藏”他们的用户，他们就无从得知到底谁访问了这个站点。
 
捡了芝麻丢西瓜，自认为放弃缓存可以精确跟踪用户，实际上，互联网中有太多的变数，想精确得到一张用户查看网站的图片？没那么简单的，亲！如果你很重视这个问题，恭喜你，本文正好提供了解决之道，即保证缓存友好，同时又能获得统计。
 
另外需要注意的是，缓存的内容都是旧的过时的。因此，如何准确更新就成了一个问题。不过不要担心，本文会向你展示如何配置服务器。
 
CDN算是个挺有意思的技术，不同于代理缓存，CDN的网关缓存和被缓存的Web站点的利益是一致的，因此，上面提到的问题对于CDN而言是没有的。不过，即使你使用了CDN，你仍要顾虑下游的代理和浏览器缓存。
 
以上为缓存可能的“糟粕”，那他好的地方呢？缓存可以让你的Web站点加载更快，让你的服务器和互联网链接间负担更小。这种差异会导致一些类似质的 变化，一个网站要几秒钟才能加载出来，而另外一个充分发挥缓存的优势，几乎瞬间显示。用户自然更喜欢那个加载迅速的站点，访问也更多。
 
再说个现实示例，许多大型互联网公司花费了数百万美元，在世界各地设立服务器集群来复制他们的内容，以使其尽可能快被他们的用户访问。缓存为你做同样的事情，而且他们更接近最终用户。最重要的是，你不要花银子。
 
实际上呢，无论你喜欢与否，代理和浏览器缓存都会被使用。如果你站点的缓存配置不正确，你只能听天由命了。


###  Web缓存如何工作

所有的缓存都有一套自己的规则，可以用来决定何时使用缓存。其中部分规则设定在协议中(HTTP 1.0 以及 1.1)，部分由缓存管理员设置。
 
>* 缓存管理员：如果指的是浏览器缓存，则有可能就是我们服务器专家同事，在服务器上配置一些缓存规则；如果是代理缓存，则指的就是处理代理服务器这块的管理人员。
    
一般而言有如下常用规则：

>* 响应头明确说明，偶不想被缓存，则不会被缓存；
>* 如果请求信息是需要认证或者安全加密的(如, HTTPS)，相应内容也不会被缓存；
>* 缓存如果有以下表现，则认为是fresh新鲜的（无需检查源服务器，直接发送给客户端）： 含有完整的过期时间和寿命控制头信息，并且内容仍在保鲜期内，或者缓存最近已展现，并且在不久前修改，则内容缓存直取，绕过源服务器。
>* 若内容陈旧，则会要求源服务器做验证 validate ，或者告诉缓存其拷贝副本是否是OK的。
>* 特定情况下——例如，断网了，之前有过的响应缓存直取而不检查源服务器。
响应如果没有类似ETag或Last-Modified头这样的校验器，也没有明确的更新信息（Expires/Cache-Control），通常（并不绝对）认为是不可缓存的。

总而言之，新鲜度freshness和校验validation是确定缓存内容是否可用的最重要途径。如果要展示的足够新，直接缓存取；如果检测发现展示内容并未变化，则不会再来一次完整的传输。

###  如何控制缓存和不缓存
 
有很多工具可以帮助设计师和网站管理员调整服务器缓存网站的方式，这也许需要你亲自动手对服务器的配置进行一些调整，但绝对值得。了解如何使用这些工具请参考本文后面的章节。


####    HTML Meta标签 vs. HTTP头信息

HTML重构人员可以在文档的<head>中添加标签进行描述。这些meta标签通常用来标记不可缓存或过期时间。
 
Meta标签使用简单，但效果一般。因为只被少数几个浏览器支持，而代理缓存基本上就不访问HTML文档。尽管我们可以在页面上试图添加no-cache meta标签让页面一直是最新的，但其实没必要。
 
如果你的网站托管在ISP或者主机托管商那里，并且他们没有赋予您任意设置HTTP头信息的能力(比如Expires和Cache-Control)，你要投诉争取，因为在你的工作中这些是必须的。
 
另外一方面： HTTP头信息可以让你对浏览器和代理服务器如何处理你的副本进行更多的控制。他们在HTML代码中是看不见的， 一般由Web服务器自动生成。但是，根据你使用的服务器，你可以在某种程度上进行控制。在下文中：你将看到一些有趣的HTTP头信息，以及如何在你的站点 上应用部署这些特性。
 
HTTP头信息发送在HTML代码之前，只能被浏览器和一些中间缓存能看到，一个典型的HTTP 1.1协议返回的头信息看上去像这样：

    HTTP/1.1 200 OK
    Server: bfe/1.0.8.9
    Date: Sat, 24 Oct 2015 02:32:59 GMT
    Content-Type: text/html
    Content-Length: 7877
    Connection: keep-alive
    Last-Modified: Wed, 03 Sep 2014 10:00:27 GMT
    ETag: "1ec5-502264e2ae4c0"
    Accept-Ranges: bytes
    Cache-Control: max-age=315360000
    Expires: Tue, 21 Oct 2025 02:32:59 GMT
    
头信息空一行后是HTML代码的输出，关于如何设置HTTP头信息请参考对应章节。


####    Pragma HTTP头信息（以及为什么不起作用）

很多人认为在HTTP头信息中设置了Pragma: no-cache后会让内容无法被缓存。但事实并非如此：HTTP的规范中，响应型头信息没有任何关于Pragma属性的说明，只说明了请求头信息（浏览器发送给服务器的头信息）中的Pragma属性。虽然有少部分缓存会买账，但大部分无视，使用Pragma没作用。若要使用，试试下面的头信息。

####    使用Expires HTTP头信息控制不过期

Expires HTTP头是控制缓存的基本手段，Expires的中文意思是“有效期”，显然，就是告诉浏览器缓存的有效期。如果过期，缓存会检查源服务器以确定文件是否改变了。Expires头几乎每个缓存都支持。

大部分的服务器允许你以多种方式设置Expires响应头。通常，他们允许设置一个绝对过期时间，然后对比最后一次访问的时候或者最后一次文档修改的时候决定客户端内容的获取方式。

对于静态图片（如导航或按钮的图片）而言，Expires头信息是相当有用的，因为图片不怎么修改，您可以给图片设置一个相当长的过期时间，这回让你的用户感觉网站变快了。Expires对于控制有改变规律的网页也很有用，例如：你有一个新闻聚合页面，每天早上6点钟准时更新，您可以设置缓存的过期 时间也是这个点，于是缓存就可以很聪明地知道什么时候该去重载新的内容，什么时候睡大觉。

Expires头唯一的有效值是HTTP时间，其他值都会被认为是“前男友前女友”之类，不会去缓存的。注意：时间是格林威治时间（GMT），而不是本地时间。如下所示：

    Expires: Fri, 30 Oct 1998 14:19:41 GMT
    
显然，如果你要使用Expires头，确保你的Web服务器时间的准备就非常重要了。使用网络时间协议(Network Time Protocol – NTP)不失为一个号方法。如果你的身边有本地系统管理员，可以向他咨询。

尽管Expires头很有用，但它有一定的局限性。首先，因为牵扯到时间，Web服务器端的时钟必须和缓存的同步，否则很可能实现不了预期的结果——缓存把前女友当初现女友，把现女友当作过去式——那就悲剧了。

另外一个问题是，你很容易忘记给某内容设置了一个特定时间，如果返回内容的时候没有更新这个过期时间，则每个请求都是上访到服务器，反而增加了负载和响应时间。

>* 网络时间协议(NTP): 以封包交换把两台电脑的时钟同步化的网络协议。NTP使用UDP端口123作为传输层。它是用作抵销可变延迟的影响。NTP是仍在使用中的最古老的网络协 议之一（在1985年前开始）。NTP最初由德拉瓦州大学的Dave Mills设计，他与一群志愿者仍在维护NTP。

####    Cache-Control（缓存控制）HTTP头信息
HTTP 1.1引入了新的头信息：Cache-Control响应头信息，让网站的发布者可以更全面的控制他们的内容，更好地处理Expires的些限制。Cache-Control有用的响应头包括：

>* max-age=[秒]：表示在这个时间范围内缓存是新鲜的无需更新。类似Expires时间，不过这个时间是相对的，而不是绝对的。也就是某次请求成功后多少秒内缓存是新鲜的。
>* s-maxage=[秒]：类似max-age, 除了仅应用于共享缓存（如代理）。
>* public：标记认证的响应才能够被缓存。一般而言，需要认证HTTP请求内容会自动私有化（不会被缓存Add）。
>* privateN：允许缓存专门为某一个用户存储响应，比方说在浏览器中；共享缓存一般不会，例如在代理中。
>* no-cache：每次在释放缓存副本之前都强制发送请求给源服务器进行验证，这在确保认证有效性上很管用（和public结合使用）或者保证内容必须是即时的，不得无视缓存的所有优点，如国内的微博、twitter等的刷新显示Add。
>* no-store：强制缓存在任何情况下都不要保留任何副本。
>* must-revalidate：告诉缓存，我给你准备了一些关于新鲜度的信息，在表现的时候要严格遵循之。HTTP允许缓存在某些特定情况下返回过期数据，指定了这个属性，相对于告诉缓存，你丫必须严格遵循我的规则。
>* proxy-revalidate：类似must-revalidate，除了只能应用于代理缓存。

例如：

    Cache-Control: max-age=3600, must-revalidate
    
如果Cache-Control和Expires同时存在，Cache-Control说了算。如果你打算使用Cache-Control头，你应该好好看看”HTTP 1.1 规范“, 详见参考文章以及拓展阅读。


####    验证器和验证

服务器以及缓存通过验证来判断内容是否改变。

验证器是很重要的，如果一个都没有，同时没有可用的新鲜度信息(Expires或Cache-Control)，缓存一点儿都不会存储内容。

最常见的验证是通过Last-Modified头信息通信确定文档最后的修改时间。如果缓存有内容存储，会包含Last-Modified信息，请求头中包含If-Modified-Since，询问服务器内容是否改变了。

HTTP 1.1引入了一个新的验证器，称为Etag。 Etag是每次展现内容改变时候由服务器生成的唯一标识符，由于服务器控制ETag如何生成，当缓存发起If-None-Match请求的时候，如果Etag匹配，就可以确定展示内容其实是一样的。

>* Etag: HTTP协议规格说明定义ETag为”被请求变量的实体值”。另一种说法是，ETag是一个可以与Web资源关联的记号（token）。典型的Web资源 可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端，以下是服务器端返回 的格式：ETag:”50b1c1d4f775c61:df3″客户端的查询更新格式是这样的：If-None-Match : W / “50b1c1d4f775c61:df3″如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样。测试Etag主要 在断点下载时比较有用。

所有新一代的Web服务器都对静态内容（如：文件）自动生成ETag和Last-Modified头信息，而你不必做任何设置。但是，服务器对于动态内容（例如：CGI, ASP或数据库生成的网站）并不知道如何生成这些信息，参考一下编写支持缓存的脚本章节。


### 创建支持缓存网站的小技巧

除了使用新鲜度信息以及验证，还有其他一些技巧可以让你网站的缓存更加友好：

>* 保持URL稳定：这是缓存的金科玉律，如果你为不同页面，不同用户或不同网站提供相同的内容，他们应该使用相同的URL. 这是简单却非常行之有效的方法。例如，你的HTML中的某个引用地址是"/index.html", 则要一直使用这个地址。
>* 不同地方的图片和其他元素使用同一库。
>* 对于不经常改变的图片/页面启用缓存，通过将Cache-Control: max-age头信息的值设大一点。
>* 对于定期更新的内容通过指定max-age或过期时间实现缓存。
>* 如果资源改变了（尤其下载文件），改变其名字。由于一般这种资源会有很长的过期时间，而服务器上一直是正确的版本；因此，链接这个下载资源的页面需要要比较短的过期时间（//zxx: 我司页面5分钟过期）。否则，会出现服务器的资源是新的，但页面被缓存了，其中的链接地址还是旧的，就会出现新旧版本冲突的可能Add。
>* 万不得已不要变动文件：否则你要设置一个新的Last-Modified值。另外，当你更新站点的时候，只要上传改动的那些文件，而不要把整个站点都覆盖过去。
>* Cookie能不用就不用：Cookie难以被缓存，且大多情境下是没有必要的。如果你非得使用Cookie，建议用在动态页面上。
>* 减少SSL⑧的使用：因为共享缓存不能存储认证页面，只在必要的时候使用，并且在SSL页面上减少图片的使用。
>* 使用REDbot⑨检查你的网站：可以帮助你应用本文所介绍的一些概念。
>* ⑧ SSL：全称Secure Socket Layer – 安全套接层，为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之 传输过程中不会被截取及窃听。目前一般通用之规格为40 bit之安全标准，美国则已推出128 bit之更高安全标准，但限制出境。只要3.0版本以上之I.E.或Netscape浏览器即可支持SSL。
>* ⑨ REDbot：REDbot = RED + robot，是个机器人，检查HTTP资源，看他们如何会表现，指出常见的问题，并提出改进建议。虽然它属于HTTP一致性测试仪，但却可以找到不少HTTP相关问题。


[http://www.oschina.net/news/41397/web-cache-knowledge?p=2](http://www.oschina.net/news/41397/web-cache-knowledge?p=2)











浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta 标签，Web开发者可以在HTML页面的<head>节点中加入<meta>标签，代码如下：

下面我主要介绍HTTP协议定义的缓存机制。

### Expires策略
Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。

### Cache-control策略（重点关注）
Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。

http协议头Cache-Control    ：
    值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age
    各个消息中的指令含义如下：
    Public指示响应可被任何缓存区缓存。
    Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。
    no-cache指示请求或响应消息不能缓存
    no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。
    max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。
    min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。
    max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。
    还是上面那个请求，web服务器返回的Cache-Control头的值为max-age=300，即5分钟（和上面的Expires时间一致，这个不是必须的）。


### Last-Modified/If-Modified-Since
Last-Modified/If-Modified-Since要配合Cache-Control使用。

l  Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。
l  If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。

Etag/If-None-Match
Etag/If-None-Match也要配合Cache-Control使用。

l  Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。
l  If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。

既生Last-Modified何生Etag？
你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

l  Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间
l  如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存
l  有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

用户行为与缓存
浏览器缓存行为还有用户的行为有关！！！

用户操作
Expires/Cache-Control
Last-Modified/Etag
地址栏回车
有效
有效
页面链接跳转
有效
有效
新开窗口
有效
有效
前进、后退
有效
有效
F5刷新
无效
有效
Ctrl+F5刷新
无效
无效
总结
浏览器第一次请求：

clip_image004

浏览器再次请求时：

clip_image006

